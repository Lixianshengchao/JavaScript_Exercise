<!DOCTYPE html>
<html>
	<head>
		<meta charset="GB2312">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
		/*在 JavaScript 中，Function(函数)类型实际上是对象。
		每个函数都是 Function 类型的 实例，而且都与其他引用类型一样具有属性和方法。
		由于函数是对象，因此函数名实际上也 是一个指向函数对象的指针。*/
/*
		//一 函数的声明方式
			//1 普通的函数声明
			function box(num1,num2){
				return num1+num2;
			}
			
			//2使用变量初始化函数
			var box=function(num1,num2){
				return num1+num2;
			}
			*/
			
			/*Javascript 中的函数名本身就是变量，所以函数也可以作为值来使用。
			也就是说，不 仅可以像传递参数一样把一个函数传递给另一个函数，
			而且可以将一个函数作为另一个函数 的结果返回。*/
			
			/*function box(sumFunction,num){
				
				return sumFunction(num); 
			}
			
			function sum(num){
				return num+10;
			}
			
			var result=box(sum,10);
			alert(result); //20
			*/
			
//			三．函数内部属性 在函数内部，有两个特殊的对象：arguments 和 this。
//			arguments 是一个类数组对象，包 含着传入函数中的所有参数，
//			主要用途是保存函数参数。但这个对象还有一个名叫 callee 的 属性，
//			该属性是一个指针，指向拥有这个 arguments 对象的函数。
			
			/*function factorial(num){
				if(num<=1){
					return 1;
				}else{
					return num*arguments.callee(num-1);
				}
			}
			
			alert(factorial(3));
			*/
		/*	
//			函数内部另一个特殊对象是 this，其行为与 Java 和 C#中的 this 大致相似。
//			换句话说， this 引用的是函数据以执行操作的对象，
//			或者说函数调用语句所处的那个作用域。
//			PS：当在 全局作用域中调用函数时，this 对象引用的就是 window。
			
			window.color='红色的';
			alert(this.color);
			
			var box={
				color:'蓝色的',
				sayColor:function(){
					alert(this.color);
				}
			};
			box.sayColor();
			alert(this.color);*/
			/*
//			ECMAScript 中的函数是对象，因此函数也有属性和方法。
//			每个函数都包含两个属性： length 和 prototype。
//			其中，length 属性表示函数希望接收的命名参数的个数。

			function box(name,age){
				alert(name+age);
			}
			alert(box.length);
			*/
			
//			对于 prototype 属性，它是保存所有实例方法的真正所在，也就是原型。
//			这个属性， 我们将在面向对象一章详细介绍。
//			而 prototype 下有两个方法：apply()和 call()，
//			每个函数都 包含这两个非继承而来的方法。
//			这两个方法的用途都在特定的作用域中调用函数，
//			实际上等 于设置函数体内 this 对象的值。
			
			/*function box(num1,num2){
				return num1+num2;
			}
			
			function sayBox(num1,num2){
				return box.apply(this,[num1,num2]);//this表示作用域，这里是window，[]表示box所需要的参数
			}
			
			function sayBox2(num1,num2){
				return box.apply(this,arguments);//arguments对象表示box所需要的参数
			}
			alert(sayBox(10,10));
			alert(sayBox2(10,10));*/
			
//			call()方法于 apply()方法相同，他们的区别仅仅在于接收参数的方式不同。
//			对于 call()方 法而言，第一个参数是作用域，没有变化，
//			变化只是其余的参数都是直接传递给函数的。
			
			/*function box(num1,num2){
				return num1+num2;
			}
			
			function callBox(num1,num2){
				return box.call(this,num1,num2);//和apply区别在于后面的传参
				
			}
			
			alert(callBox(10,10));
			*/
//			事实上，传递参数并不是 apply()和 call()方法真正的用武之地；
//			它们经常使用的地方是 能够扩展函数赖以运行的作用域。
			
			/*var color='红色的';//或者window.color='红色的'
			var box={
				color:'蓝色的'
				
			};
			
			function sayColor(){
				alert(this.color);
			}
			
			sayColor();
			sayColor.call(this);
			sayColor.call(window);
			sayColor.call(box);
			*/
//			这个例子是之前作用域理解的例子修改而成，
//			我们可以发现当我们使用 call(box)方法的 时候，
//			sayColor()方法的运行环境已经变成了 box 对象里了。 
//			使用 call()或者 apply()来扩充作用域的最大好处，
//			就是对象不需要与方法发生任何耦合 关系(耦合，就是互相关联的意思，扩展和维护会发生连锁反应)。
//			也就是说，box 对象和 sayColor()方法之间不会有多余的关联操作，
//			比如 box.sayColor=sayColor;
			
		</script>
		 
	</body>
</html>
 